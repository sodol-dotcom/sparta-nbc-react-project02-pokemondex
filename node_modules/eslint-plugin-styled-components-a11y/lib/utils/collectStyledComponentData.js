"use strict";

var isStyledCallExpression = function isStyledCallExpression(node) {
  return node.tag.type === 'CallExpression';
};
var isStyledFunc = function isStyledFunc(node) {
  var _node$tag$callee;
  return ((_node$tag$callee = node.tag.callee) === null || _node$tag$callee === void 0 ? void 0 : _node$tag$callee.name) === 'styled';
};
var isStyledFuncComponentArgument = function isStyledFuncComponentArgument(node) {
  var _node$tag$arguments, _node$tag$arguments$;
  return isStyledFunc(node) && ((_node$tag$arguments = node.tag.arguments) === null || _node$tag$arguments === void 0 ? void 0 : (_node$tag$arguments$ = _node$tag$arguments[0]) === null || _node$tag$arguments$ === void 0 ? void 0 : _node$tag$arguments$.type) === 'Identifier';
};
var isStyledFuncStringArgument = function isStyledFuncStringArgument(node) {
  var _node$tag$arguments2, _node$tag$arguments2$;
  return isStyledFunc(node) && ((_node$tag$arguments2 = node.tag.arguments) === null || _node$tag$arguments2 === void 0 ? void 0 : (_node$tag$arguments2$ = _node$tag$arguments2[0]) === null || _node$tag$arguments2$ === void 0 ? void 0 : _node$tag$arguments2$.type) === 'Literal';
};
var isStyledFuncWithAttrs = function isStyledFuncWithAttrs(node) {
  var _node$tag$callee2, _node$tag$callee2$obj, _node$tag$callee2$obj2;
  return ((_node$tag$callee2 = node.tag.callee) === null || _node$tag$callee2 === void 0 ? void 0 : (_node$tag$callee2$obj = _node$tag$callee2.object) === null || _node$tag$callee2$obj === void 0 ? void 0 : (_node$tag$callee2$obj2 = _node$tag$callee2$obj.callee) === null || _node$tag$callee2$obj2 === void 0 ? void 0 : _node$tag$callee2$obj2.name) === 'styled' && isAttrs(node);
};
var isStyledStringArgumentFuncWithAttrs = function isStyledStringArgumentFuncWithAttrs(node) {
  var _node$tag$callee3, _node$tag$callee3$obj, _node$tag$callee3$obj2, _node$tag$callee3$obj3;
  return isStyledFuncWithAttrs(node) && ((_node$tag$callee3 = node.tag.callee) === null || _node$tag$callee3 === void 0 ? void 0 : (_node$tag$callee3$obj = _node$tag$callee3.object) === null || _node$tag$callee3$obj === void 0 ? void 0 : (_node$tag$callee3$obj2 = _node$tag$callee3$obj.arguments) === null || _node$tag$callee3$obj2 === void 0 ? void 0 : (_node$tag$callee3$obj3 = _node$tag$callee3$obj2[0]) === null || _node$tag$callee3$obj3 === void 0 ? void 0 : _node$tag$callee3$obj3.type) === 'Literal';
};
var isStyledComponentArgumentFuncWithAttrs = function isStyledComponentArgumentFuncWithAttrs(node) {
  var _node$tag$callee4, _node$tag$callee4$obj, _node$tag$callee4$obj2, _node$tag$callee4$obj3;
  return isStyledFuncWithAttrs(node) && ((_node$tag$callee4 = node.tag.callee) === null || _node$tag$callee4 === void 0 ? void 0 : (_node$tag$callee4$obj = _node$tag$callee4.object) === null || _node$tag$callee4$obj === void 0 ? void 0 : (_node$tag$callee4$obj2 = _node$tag$callee4$obj.arguments) === null || _node$tag$callee4$obj2 === void 0 ? void 0 : (_node$tag$callee4$obj3 = _node$tag$callee4$obj2[0]) === null || _node$tag$callee4$obj3 === void 0 ? void 0 : _node$tag$callee4$obj3.type) === 'Identifier';
};
var styledCallElementObjectMapArgumentTag = function styledCallElementObjectMapArgumentTag(node) {
  var _node$tag, _node$tag$arguments3, _node$tag$arguments3$, _node$tag$arguments3$2;
  return (_node$tag = node.tag) === null || _node$tag === void 0 ? void 0 : (_node$tag$arguments3 = _node$tag.arguments) === null || _node$tag$arguments3 === void 0 ? void 0 : (_node$tag$arguments3$ = _node$tag$arguments3[0]) === null || _node$tag$arguments3$ === void 0 ? void 0 : (_node$tag$arguments3$2 = _node$tag$arguments3$.property) === null || _node$tag$arguments3$2 === void 0 ? void 0 : _node$tag$arguments3$2.name;
};
var isPlainSTE = function isPlainSTE(node) {
  var _node$tag2, _node$tag2$object;
  return node.tag.type === 'MemberExpression' && ((_node$tag2 = node.tag) === null || _node$tag2 === void 0 ? void 0 : (_node$tag2$object = _node$tag2.object) === null || _node$tag2$object === void 0 ? void 0 : _node$tag2$object.name) === 'styled';
};
var isAttrs = function isAttrs(_ref) {
  var _tag$callee, _tag$callee$property;
  var tag = _ref.tag;
  return ((_tag$callee = tag.callee) === null || _tag$callee === void 0 ? void 0 : (_tag$callee$property = _tag$callee.property) === null || _tag$callee$property === void 0 ? void 0 : _tag$callee$property.name) === 'attrs';
};
var getAttrsType = function getAttrsType(node) {
  var _node$tag3, _node$tag3$arguments, _node$tag3$arguments$;
  var type = (_node$tag3 = node.tag) === null || _node$tag3 === void 0 ? void 0 : (_node$tag3$arguments = _node$tag3.arguments) === null || _node$tag3$arguments === void 0 ? void 0 : (_node$tag3$arguments$ = _node$tag3$arguments[0]) === null || _node$tag3$arguments$ === void 0 ? void 0 : _node$tag3$arguments$.type;
  return type === 'FunctionExpression' ? 'func' : type === 'ArrowFunctionExpression' ? 'arrow' : type === 'ObjectExpression' ? 'object' : '';
};
var _require = require('util'),
  inspect = _require.inspect;
var _require2 = require('./constants'),
  __UNKNOWN_IDENTIFER__ = _require2.__UNKNOWN_IDENTIFER__;
module.exports = function (styledComponentsDict, context, name) {
  return {
    TaggedTemplateExpression: function TaggedTemplateExpression(node) {
      var func = function func(inspectee) {
        return name.includes('html-has-lang') && context.report(node, "made it here: ".concat(inspect(inspectee || node)));
      };
      var scName = node.parent.id && node.parent.id.name;
      if (!scName) {
        var _node$parent$key, _node$parent$parent, _node$parent$parent$p, _node$parent$parent$p2;
        if (isPlainSTE(node) && (_node$parent$key = node.parent.key) !== null && _node$parent$key !== void 0 && _node$parent$key.name && (_node$parent$parent = node.parent.parent) !== null && _node$parent$parent !== void 0 && (_node$parent$parent$p = _node$parent$parent.parent) !== null && _node$parent$parent$p !== void 0 && (_node$parent$parent$p2 = _node$parent$parent$p.id) !== null && _node$parent$parent$p2 !== void 0 && _node$parent$parent$p2.name) {
          scName = "".concat(node.parent.parent.parent.id.name, ".").concat(node.parent.key.name);
        } else {
          return;
        }
      }
      var attrs = [];
      var tag = '';

      // styled(Component)`` || styled.div.attrs(...)`` || styled('div')``
      if (isStyledCallExpression(node)) {
        // styled(animated.div)``
        if (styledCallElementObjectMapArgumentTag(node)) {
          tag = styledCallElementObjectMapArgumentTag(node);
        }
        // styled('div')``;
        else if (isStyledFuncStringArgument(node)) {
          var _node$tag$arguments4, _node$tag$arguments4$;
          tag = ((_node$tag$arguments4 = node.tag.arguments) === null || _node$tag$arguments4 === void 0 ? void 0 : (_node$tag$arguments4$ = _node$tag$arguments4[0]) === null || _node$tag$arguments4$ === void 0 ? void 0 : _node$tag$arguments4$.value) || '';
        }

        // styled(Component)`` || styled(Component).attrs(...)``
        if (isStyledFuncComponentArgument(node) || isStyledComponentArgumentFuncWithAttrs(node)) {
          var _context$settings$jsx, _context$settings, _context$settings$jsx2;
          var ancestorScName = isStyledFuncComponentArgument(node) ? node.tag.arguments[0].name : node.tag.callee.object.arguments[0].name;

          /**
           * enable checking custom components
           * @see https://github.com/jsx-eslint/eslint-plugin-jsx-a11y#usage
           */
          var componentMap = (_context$settings$jsx = (_context$settings = context.settings) === null || _context$settings === void 0 ? void 0 : (_context$settings$jsx2 = _context$settings['jsx-a11y']) === null || _context$settings$jsx2 === void 0 ? void 0 : _context$settings$jsx2.components) !== null && _context$settings$jsx !== void 0 ? _context$settings$jsx : {};

          // styled(StyledComponent)`` || styled(StyledComponent).attrs(...)``
          if (styledComponentsDict[ancestorScName]) {
            attrs = styledComponentsDict[ancestorScName].attrs;
            tag = styledComponentsDict[ancestorScName].tag;
          }

          // styled(CustomComponent)`` || styled(CustomComponent).attrs(...)``
          if (componentMap[ancestorScName]) {
            tag = componentMap[ancestorScName];
          }
        }

        // styled.div.attrs(...)`` || styled(Component).attrs(...)`` || styled('div').attrs(...)``
        if (isAttrs(node) || isStyledFuncWithAttrs(node)) {
          var attrsPropertiesArr = [];
          var attrsNode = node.tag.arguments[0];
          if (isStyledStringArgumentFuncWithAttrs(node)) {
            var _node$tag$callee5, _node$tag$callee5$obj, _node$tag$callee5$obj2, _node$tag$callee5$obj3;
            tag = (_node$tag$callee5 = node.tag.callee) === null || _node$tag$callee5 === void 0 ? void 0 : (_node$tag$callee5$obj = _node$tag$callee5.object) === null || _node$tag$callee5$obj === void 0 ? void 0 : (_node$tag$callee5$obj2 = _node$tag$callee5$obj.arguments) === null || _node$tag$callee5$obj2 === void 0 ? void 0 : (_node$tag$callee5$obj3 = _node$tag$callee5$obj2[0]) === null || _node$tag$callee5$obj3 === void 0 ? void 0 : _node$tag$callee5$obj3.value;
          } else if (!isStyledComponentArgumentFuncWithAttrs(node)) {
            var _node$tag$callee$obje;
            tag = (_node$tag$callee$obje = node.tag.callee.object.property) === null || _node$tag$callee$obje === void 0 ? void 0 : _node$tag$callee$obje.name;
          }
          var attrsType = getAttrsType(node);
          if (!tag || !attrsType) return;
          // styled.div.attrs(function() { return {} })``

          // TODO all these empty array defaults are a temp fix. Should get a better way of actually trying to see what
          //  is returned from function attrs in the case they aren't just simple immediate returns, e.g., if else statements
          if (attrsType === 'arrow') {
            var _attrsNode$body;
            attrsPropertiesArr = (attrsNode === null || attrsNode === void 0 ? void 0 : (_attrsNode$body = attrsNode.body) === null || _attrsNode$body === void 0 ? void 0 : _attrsNode$body.properties) || [];
            // styled.div.attrs(() => ({}))``
          } else if (attrsType === 'func') {
            var _attrsNode$body2, _attrsNode$body2$body, _attrsNode$body2$body2, _attrsNode$body2$body3;
            attrsPropertiesArr = (attrsNode === null || attrsNode === void 0 ? void 0 : (_attrsNode$body2 = attrsNode.body) === null || _attrsNode$body2 === void 0 ? void 0 : (_attrsNode$body2$body = _attrsNode$body2.body) === null || _attrsNode$body2$body === void 0 ? void 0 : (_attrsNode$body2$body2 = _attrsNode$body2$body.find(function (x) {
              return x.type === 'ReturnStatement';
            })) === null || _attrsNode$body2$body2 === void 0 ? void 0 : (_attrsNode$body2$body3 = _attrsNode$body2$body2.argument) === null || _attrsNode$body2$body3 === void 0 ? void 0 : _attrsNode$body2$body3.properties) || [];
            // styled.div.attrs({})``
          } else if (attrsType === 'object') {
            attrsPropertiesArr = (attrsNode === null || attrsNode === void 0 ? void 0 : attrsNode.properties) || [];
          }
          var arithmeticUnaryOperators = ['+', '-'];
          // filter out spread elements (which have no key nor value)
          attrs = attrs.concat(attrsPropertiesArr.filter(function (x) {
            return x.key;
          }).map(function (x) {
            return {
              key: x.key.name || x.key.value,
              // this is pretty useless. would need to generate code from any template expression for this to really work
              value: x.value.type === 'TemplateLiteral' ?
              // need to grab falsy vals like empty strings, thus the x ? x : identifier instead of x|| identifier
              typeof x.value.quasis[0].value.raw === 'undefined' ? __UNKNOWN_IDENTIFER__ : x.value.quasis[0].value.raw : x.value.type === 'UnaryExpression' && arithmeticUnaryOperators.includes(x.value.operator) ?
              // if simple arithemetic, concat the symbol and the strings (like a negative) and then coerce to a number
              +(x.value.operator + x.value.argument.value) : x.value.type === 'Identifier' ? x.value.name === 'undefined' ? undefined : __UNKNOWN_IDENTIFER__ : typeof x.value.value === 'undefined' ?
              // if property exists, but no value found, just set it to our unknown identifier so it returns truthy and not something specific like a number or boolean or undefined as these are tested in specific ways for different linting rules
              // too many options for what this could be, but this can approxinate what is needed for linting
              // need to grab falsy vals like empty strings, thus the x ? x : identifier instead of x|| identifier
              __UNKNOWN_IDENTIFER__ : x.value.value
            };
          }));
        }
        styledComponentsDict[scName] = {
          name: scName,
          attrs: attrs,
          tag: tag
        };
      }

      // const A = styled.div``
      if (isPlainSTE(node)) {
        tag = node.tag.property.name;
        styledComponentsDict[scName] = {
          name: scName,
          tag: tag,
          attrs: attrs
        };
      }
    }
  };
};